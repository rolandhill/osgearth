/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
* Copyright 2008-2013 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_TILE_NODE
#define OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_TILE_NODE 1

#include "Common"
#include "TileModel"
#include <osg/MatrixTransform>

namespace osgEarth { namespace Drivers { namespace MPTerrainEngine
{
    using namespace osgEarth;
    class TileNode;

    /**
     * Marker that gives access to a TileNode.
     */
    class TileNodeContainer
    {
    public:
        virtual TileNode* getTileNode() = 0;
    };

    class MPTerrainEngineNode;

    /**
     * Node that represents a single terrain tile that was compiled from
     * a TileModel (and corresponds to one TileKey). The matrixtransform
     * localizes the TileNode within the terrain.
     */
    class TileNode : public osg::MatrixTransform, public TileNodeContainer
    {
    public:
        /**
         * Constructs a new tile node
         */
        TileNode( const TileKey& key, const TileModel* model );

        /**
         * The tilekey associated with this tile
         */
        const TileKey& getKey() const { return _key; }

        /**
         * True if this is a valid tile node.
         * Subclass may override (see InvalidTileNode)
         */
        virtual bool isValid() const { return true; }

        /**
         * Access the source data model that built this tile.
         */
        const TileModel* getTileModel() { return _model.get(); }

        /**
         * Sets the last traversal frame manually. A parent TileGroup
         * will call this to prevent the born-time from resetting
         * when traversing the tile's children.
         */
        void setLastTraversalFrame(unsigned frame);

        /**
         * Tells the tile node the current map revision, which is turn
         * will determine whether the tile is dirty and needs updating.
         */
        void setMapRevision( const Revision& value ) { _maprevision = value; }

        /**
         * Flags this Tile as dirty, regardless of whether the revisions are in sync.
         */
        void setDirty() { _dirty = true; }

        /**
         * Whether the tile is dirty and was traversed (and if therefore ready for
         * a dynamic update)
         */
        bool isOutOfDate() const { return _outOfDate; }


    public: // TileNodeContainer

        TileNode* getTileNode() { return this; }

        /**
        * Sets the TerrainEngineNode so we can access it later
        */
		void setTerrainEngineNode(MPTerrainEngineNode* mpt) { _terrainEngineNode = mpt; }

        unsigned int getFrameNumber() { return _frameNumber; }

        /**
        * Set the bounding tiles. These will be 'pending' until AdjustEdges is called
        */
		void setBoundTileW(TileNode* tilenode) { _boundTileW_pending = tilenode; }
		void setBoundTileN(TileNode* tilenode) { _boundTileN_pending = tilenode; }
		void setBoundTileE(TileNode* tilenode) { _boundTileE_pending = tilenode; }
		void setBoundTileS(TileNode* tilenode) { _boundTileS_pending = tilenode; }


        /**
        * Return the bounding tiles if they have been set.
        */
		TileNode* getBoundTileW() { return _boundTileW; }
		TileNode* getBoundTileN() { return _boundTileN; }
		TileNode* getBoundTileE() { return _boundTileE; }
		TileNode* getBoundTileS() { return _boundTileS; }


        /**
        * Adjust all the edges to match the boundary tiles as set by the _boundTile?_pending members.
        */
		void AdjustEdges();

        /**
        * Check if boundary tiles are still being used in the display and reset any edge adjustments if they are not.
        */
		void CheckOrphanedBoundaries(unsigned int framenumber);


        /**
        * Get a reference to the array that matches X & Y in the HeightField to an index in the vertex array
        */
		std::vector< short >& getIndices() { return _indices; }

    public: // OVERRIDES

        virtual void traverse( class osg::NodeVisitor& nv );

        virtual void resizeGLObjectBuffers(unsigned maxSize);
        virtual void releaseGLObjects(osg::State* state) const;

    protected:

        virtual ~TileNode() { }

        osg::Vec3Array* getVertexArray();

        void AdjustEdgeW(osg::Vec3d center);
        void AdjustEdgeN(osg::Vec3d center);
        void AdjustEdgeE(osg::Vec3d center);
        void AdjustEdgeS(osg::Vec3d center);

        void ResetEdgeW();
        void ResetEdgeN();
        void ResetEdgeE();
        void ResetEdgeS();

        TileKey                            _key;
        osg::ref_ptr<const TileModel>      _model;
        osg::ref_ptr<osg::Uniform>         _tileParentMatrixUniform;
        unsigned                           _lastTraversalFrame;
        Revision                           _maprevision;
        bool                               _outOfDate;
        bool                               _dirty;

        unsigned int                       _frameNumber;

        MPTerrainEngineNode*               _terrainEngineNode;

        osg::ref_ptr<TileNode>             _boundTileW;
        osg::ref_ptr<TileNode>             _boundTileN;
        osg::ref_ptr<TileNode>             _boundTileE;
        osg::ref_ptr<TileNode>             _boundTileS;

        osg::ref_ptr<TileNode>             _boundTileW_pending;
        osg::ref_ptr<TileNode>             _boundTileN_pending;
        osg::ref_ptr<TileNode>             _boundTileE_pending;
        osg::ref_ptr<TileNode>             _boundTileS_pending;

        std::vector< short >               _indices;
    };


    typedef std::vector< osg::ref_ptr<TileNode> > TileNodeVector;


    /**
     * Marker class - the engine will return one of these when a TileNode
     * load fails permanently. It will also blacklist the TileKey.
     */
    class InvalidTileNode : public TileNode
    {
    public:
        InvalidTileNode(const TileKey& key) : TileNode(key, 0L) { }
        bool isValid() const { return false; }
    protected:
        virtual ~InvalidTileNode() { }
    };


} } } // namespace osgEarth::Drivers::MPTerrainEngine

#endif // OSGEARTH_DRIVERS_MP_TERRAIN_ENGINE_TILE_NODE
